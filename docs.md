ㅇㄴㄹㄴㅇㄹ# `이펙티브 소프트웨어 테스팅` 내용정리

# 2장 명세 기반 테스트

### 2.4 현업에서의 명세 테스트

명세 테스트는 어느정도로 수행해야 하는가?

- 실패의 위험성을 이해해야 함. 실패하면 발생하는 비용은? 비용이 높으면 테스트에 많이 투자 필요.

# 3장 구조적 테스트와 코드 커버리지

## 3.4.2 MC/DC를 달성하는 테스트 스위트 작성

MC: 변형 조건 (Modified Condition)

DC: 결정 커버리지 (Decision Coverage)

MC/DC는 커버리지 기준 중 하나. 각 조건이 전체 결정(결과)에 어떻게 영향을 미치는지 검증.

> 조건

```
A && (B || C)
```

위의 조건이 있을 때, 각 조건은 true/false 두 가지로 표현할 수 있기 때문에 총 2의 3승개로 8개가 나온다.

| 테스트 케이스 | A    | B     | C     | 판정    |
| ------- | ----- | ----- | ----- | ----- |
| T1      | true  | true  | true  | true  |
| T2      | true  | true  | false | true  |
| T3      | true  | false | true  | true  |
| T4      | true  | false | false | false |
| T5      | false | true  | true  | false |
| T6      | false | true  | false | false |
| T7      | false | false | true  | false |
| T8      | false | false | false | false |

**MC/DC 달성 조건**은 **==각 조건이 결과에 독립적으로 영향을 미치는지==** 확인하는 것이다.

예를 들어, A 조건은 바꾸고 B와 C의 조건은 고정하고 판정(결과)가 바뀌는 경우가 해당된다.


> A의 조건이 결과에 독립적인 영향을 끼치는 경우

| 테스트 케이스 | A     | B    | C    | 판정    |
| ------- | ----- | ---- | ---- | ----- |
| T1      | true  | true | true | true  |
| T5      | false | true | true | false |

| 테스트 케이스 | A     | B    | C     | 판정    |
| ------- | ----- | ---- | ----- | ----- |
| T2      | true  | true | false | true  |
| T6      | false | true | false | false |

| 테스트 케이스 | A     | B     | C    | 판정    |
| ------- | ----- | ----- | ---- | ----- |
| T3      | true  | false | true | true  |
| T7      | false | false | true | false |

> B의 조건이 결과에 독립적인 영향을 끼치는 경우

| 테스트 케이스 | A    | B     | C     | 판정    |
| ------- | ----- | ----- | ----- | ----- |
| T2      | true  | true  | false | true  |
| T4      | true  | false | false | false |


> C의 조건이 결과에 독립적인 영향을 끼치는 경우

| 테스트 케이스 | A     | B     | C     | 판정    |
| ------- | ----- | ----- | ----- | ----- |
| T3      | true  | false | true  | true  |
| T4      | true  | false | false | false |


정리해보면,

- A: 1+5, 2+6, 3+7
- B: 2+4
- C: 3+4

각 변수마다 쌍이 하나만 있으면 충분하다. 즉, B와 C의 2,3,4 테스트케이스는 꼭 필요하다고 판단하는거다.



A에서 독립쌍을 구할 때는 테스트케이스를 줄일 수 있도록 이미 필요하다고 판단한 2,3,4 중 포함된 것을 고르는것이 효율적으로 판단된다. 2+6, 3+7 중 한 가지를 고르면 N+1개의 테스트케이스만으로 꼭 필요한 테스트케이스를 구현할 수 있다.


## 3.10 현업에서의 구조적 테스트

### 3.10.1 왜 사람들은 코드 커버리지를 싫어할까?

‘단언문 없이 테스트 케이스만 작성해도 커버리지를 100% 달성할 수 있어요. 하지만 아무것도 테스트하지는 않죠!’

필자는 이는 최악의 시나리오라고 표현.

사람들은 커버리지 숫자를 무작정 보면 안된다고 한다.

전적으로 동감하지만, 코드 커버리지를 바라보는 방식에 문제가 있다고 판단.

구조적 테스트와 코드 커버리지 과정을 통해 명세를 강화하고 테스트 스위트가 수행하지 않는 코드 부분을 재빨리 찾아내며, 명세 기반 테스트를 수행할 때 놓쳤던 구획을 찾을 수 있다.

코드 줄을 수행하지 않고 내버려 두었다는 것은 다른 의미로 수행할 지 고민 후 수행하지 않기로 결정했다는 뜻이기도 함.

→ 정리하자면, 쉽게 말해 테스트 과정에서 구멍난 부분을 채울 수 있는 좋은 수단.

코드 커버리지를 지지하는 증거 및 주장들

- 허찬스(Hutchins)와 동료들의연구: 90% 이상 커버리지를 달성한 테스트는 무작위로 선택한 비슷한 크기의 테스트에 비해 훨씬 나은 에러 방지 효과가 있음. 그 효과는 90%에서 100%으로 증가할 때 더 크게 개선됨. 그치만 무작정 100%를 달성하는 것에는 큰 의미가 없음.

### 3.10.4 표현식이 너무 복잡해서 단순화할 수 없다면 MC/DC 를 고려하자

### 3.10.6 무엇을 수행하지 말아야 할까?

```java

public static String resourceFolder(String path) {
    try {
        return Paths.get(ResourceUtils.class.getResource("/").toURI()).toString() + path;
    } catch (URISyntaxException e) {
        throw new RuntimeException(e);
    }
}
```

위의 코드는 checked exception을 감싸서 unchecked exception 으로 던지는 메소드임.

이 메소드의 예외를 일부러 터트려서 테스트함으로써 우리가 가져가는 이점이 명확하지 않다.

차라리 `resourceFolder` 가 `RuntimeException` 를 던졌을 때 시스템에 끼치는 영향을 테스트 하는 것이 더 의미가 있겠음.

작가의 의견:

코드 커버리지를 100%를 목표로 시작하되, 불필요한 부분이 보이면 예외를 두는 방식이 버그를 막기에 더 의미있다고 생각.

## 3.11 돌연변이 테스트

[https://pitest.org/](https://pitest.org/)

자바에서 돌연변이 테스트를 수행해주는 도구

테스트 도구는 코드를 돌연변이로 바꾸기만 할 뿐이라, 돌연변이 중에 불필요한 돌연변이를 걸러내야함

# 4. 계약 설계

## 4.1 사전 조건과 사후 조건

- 사전조건: 메서드가 제대로 실행되기 위한 조건
    - 예) 입력인자가 양수여야한다, DB 커넥션이 정상적으로 되어있어야한다, http connection이 되어야 한다 등..
- 사후조건: 메서드가 제대로 결과를 수행한 결과
    - 예) 특정테이블에 로우가 1개 추가된다, 리턴값이 양수여야한다, DB에 저장된 값이 리턴된다 등…

저자는 일단 무조건 문서로 기제해둬야한다고 함.

자바로 치면 메서드 위 자바독 형식으로 @param과 @return을 작성.

경우에 따라, 무조건 예외를 던지지 않고 어느정도 허용할 수 있다.

예외를 던져서 흐름을 중단시키는 것을 ‘강한 조건’, 의도한 결과가 안 날수도 있지만 허용하고보는 ‘약한 조건’

예외를 내기도, 그냥 흘러보내기도 애매하다면 기본값 혹은 에러값을 리턴하는것도 방법

### 4.2 불변식

사전 조건과 사후 조건을 구현하고 나면, 절대 변하지 않는 조건이 생긴다.

예를들어, 상품을 장바구니에 넣고 빼도 총액은 음수가 될 수 없다.

이 변하지 않는 조건을 불변식 이라고 함.

상품을 넣고 빼는 각 메서드 마지막에 총액은 음수가 될 수 없음을 추가하면 불변식 검증 가능

### 4.3 계약 변경과 리스코프 치환 법칙

**계약은 약화(느슨)되면 영향을 끼치지 않지만, 강화 되면 영향을 끼칠 수 있다.**

예) 만약 value ≥ 0 조건의 사전 조건이 value ≥ 100 조건으로 변경된다면?

해당 함수로 50이나 0값을 넘기던 연관 클래스입장에서는 예상치 못한 예외가 발생할 수 있다.

나의 느낀점: 처음부터 강한 제약을 걸고 요구사항이 변경되거나 명확해 질 때 약화시키는 방법이 좋을 수 있겠다.

### 4.3.1 상속

자바에서 상속했다고 가정했을 때,

자식 클래스는 부모 클래스의 사전 조건보다 같거나 약해야 함. (더 넓은 데이터 수용)

자식 클래스는 부모클래스의 사후 조건보다 같거나 강해야 함. (더 한정된 데이터 리턴)

클라이언트는 부모 클래스를 기준으로 사전 조건과 사후 조건을 알 수 있기 때문이다.

리스코프 치환 법칙 = 시스템에 기대하는 동작을 깨트리지 않고 자식 클래스를 부모 클래스로 치환할 수 있는 개념

## 4.4 계약에 의한 설계가 테스트와 어떤 관련이 있는가?

1. 단언문을 통해 제품 코드에서 버그를 일찍 발견할 수 있다.
2. 사전 조건, 사후 조건, 불변식은 개발자에게 테스트 대상을 제공한다.
3. 명시적인 계약은 소비자가 편함.

# 5. 속성 기반 테스트


# 6. 테스트 더블과 모의 객체


## 6.3. 현업에서의 모의 객체

### 6.3.5 모의에 관한 외부 의견

(구글 엔지니어는 이렇게 한다에 나온 내용 중 저자 관점에서 정리한 내용.)

**테스트 더블을 사용하려면 시스템이 테스트 가능성을 가지도록 설계해야 한다.**


**실제 구현에 충실하게 테스트 더ㄹ을 구축하는 일은 어렵다. 하지만 가능한한 그렇게 해야 한다.**
- 예를들어 원래 양수만 리턴하던 모의객체가 요구사항이 바뀌어 음수도 리턴하게 된다면? 그 결과가 테스트하려는 대상의 흐름에 영향이 크다면?
- 기존엔 양수만 리턴하는것을 예상하고 테스트를 짰을 것 이기 때문에 요구사항이 바뀌더라도 테스트가 다 성공할 수 있음
- 그래서 실제 구현에 충실하게 테스트 더블을 구축하는 것은 어렵다.
- 그렇지만 노력해야함.

**고립성보다 현실성이 낫다. 가능하다면 페이크나 스텁, 모의 객체보다 실제 구현을 선택하도록 하자.**
- 가능하면 실제 구현을 하자
- 실제 의존성 테스트가 너무 어려워 진다면 모의하자

**실제 구현을 사용하는 일이 불가능하거나 너무 비용이 많이 든다면 모의 객체보다 페이크를 사용한다.**
- 이 부분은 저자가 동의하지는 않는다고 함.
- 페이크가 실제 구현과 동일하지않을 수 있으니

**너무 많이 사용하면 테스트가 불분명해짐, 깨지기 쉬움, 덜 효과적**
- 모의가 너무 많이 필요하면 클래스 설계가 제대로 안된 것 일 수 있음

**모의할 때는 상호작용 테스트보다 상태 테스트가 낫다**

**너무 구체화된 상호작용 테스트는 피하자. 인수 및 기능 테스트에 초점을 두자**
- 좋은 의견이자 모범사례
- 테스트할 의미가 있는 상호작용만 검증하자

**좋은 상호작용 테스트를 작성하려면 테스트 대상 시스템을 설계할 때 엄격한 지침이 필요하다. 구글 엔지니어들은 이것을 하지 않는 경향이 있다.**

# 7. 테스트 가능성을 위한 설계

어떤 시스템은 테스트하기가 너무 힘듦

테스트 가능성: 테스트 대상 시스템이나 클래스, 메서드에 대해 자동 테스트를 얼마나 쉽게 작성할 수 있는지

## 7.1. 도메인 코드에서 인프라 코드를 분리하기

**포트와 어댑터 패턴**


## 7.5. 현업에서의 테스트 가능성 설계

### 7.5.4. private 메서드와 테스트 가능성

private 메서드로 분리하는 경우가 많음.
이러한 느낌이 드는 이유는 대개 private 메서드의 응딥도가 떨어지고 복잡하기 때문.
public 메서드와 다른 작업을 수행하거나 작업이 너무 복합해서 분리헤서 테스트 하려고 함.
-> 설계 관점에서, 이 private 메서드가 현재 위치에 있어서는 안된다는 뜻일 수 있다.

그 메서드를 추출해서 새로운 클래스로 옮기는 방법

# 8. 테스트 주도 개발


# 9. 대규모 테스트 작성

## 9.4. 대규모 테스트에 대한 마지막 논의

### 9.4.1 테스트는 어느수준으로?

저자의 추천.
모든것을 단위 수준에서 수행.
대규모 테스트에서는 가장 중요한 행위를 수행하자.

### 9.4.2. 비용/이득 분석을 수행하자

좋은 테스트 = 적은 비용, 중요한 버그 해결
단위테스트가 비용이 가장 저렴

### 9.4.3 수행은 되었지만 테스트 되지 않은 메서드를 조심하자

### 9.4.4. 적합한 코드 인프라가 핵심이다

통합테스트와 시스템 테스트는 둘 다 배후에 적절한 인프라가 필요함.

### 9.4.5. DSL과 테스트를 작성하는 이해 관계자를 위한 도구

큐컴버...

### 9.4.6. 다른 종류의 웹 시스템에 대한 테스트 

웹 테스트와 같이 테스트 수준이높을수록 애플리케이션이 실행되는 프레임워크와 환경에 대해 더 많이 생각하게 된다.

# 10. 테스트 코드 품질

"테스트 감염"
테스트를 관리하지 않으면 부패함.

테스트도 제품코드 관리하듯 계속 관리해줘야함.

"테스트 냄새"

## 10.1 테스트 코드의 유지 보수성을 위한 원칙

### 10.1.1 테스트는 빨라야 한다.

느리면 -> 테스트 안하게되고 -> 비효율적
우수한테스트는 빠르다.

해결방법
- 느린코드와 빠른 코드를 분리한다.
- 느리면 모의/스텁
- 느린 테스트를 자주 실행하지 않는 다른 테스트 스위트로 옮긴다.

빨리 실행할 수 있는걸 느린 테스트 때문에 묶인 테스트가 느려짐을 방지

### 10.1.2 테스트는 응집력 있고 독립적이며 격리되어야 한다

하나의 테스트 메서드가 하나의 기능이나 시스템 행위를 테스트 하는 것이 이상적임

"살찐 테스트"
여러 기능을 수행하며 종종 구현 관점에서도 복잡하다

복잡한 테스트는 무엇을 테스트 하는지 알기 어려움.
차라리 쪼개서 작은 여러개의 테스트가 낫다.

테스트는 다른 테스트의 결과에 의존하면 안된다.

다른 테스트에 의존적인 테스트는, 테스트 스위트를 리팩터링 해서 필요한 전체 환경을 다시 설정해야 함.
디스크에 파일을 만들거나, 디비에 값을 넣거나 하는것들을 모두 삭제하자.

### 10.1.3 테스트는 존재 이유가 있어야 한다

테스트에는 목적이 있어야함.
예) 버그찾기, 행위 문서화 등

목적이 분명하면 코드 변경 시 유지보수가 용이함.
목적이 명확하지 않으면 코드가 변경될 때 해당 테스트가 여전히 유효한지 판단하기 어려움.

### 10.1.4 테스트는 반복 가능해야 하며 불안정하지 않아야 한다

"반복 가능한 테스트"

어떨 때는 통과하고 어떨 때는 실패하는 경우 불안정한 테스트
-> 개발팀의 생산성을 떨어트림

- 외부 자원이나 공유 자원에 의존하는 경우
	- 데이터베이스에 의존.
	- 테스트 실행 시 디비 상태가 안좋으면? 기대하지 않는 데이터를 포함하고 있으면? 두 개발자가 동시에 하나의 데이터베이스를 바라보고 실행하면?
- 부정확한 타임아웃
	- 웹 테스트에서 흔히 발생. 
	- 평소보다 느리면 실패해버림
- 다른 테스트 메서드와 예상치 못한 상호작용이 일어난 경우
	- 테스트A가 테스트B에 영향을 끼쳐서 실패를 유발

원인
- 비동기식 대기, 동시성, 테스트 순서 의존성 -> 가장 흔한 불안정성의 원인
- 대부분의 불안정한 테스트는 작성할 때 부터 불안정함
- 플랫폼 특성으로 인해 발생하는 일은 드뭄 (운영체제가 다르다고 해서 실패에 영향을 미치지는 않음)
- 외부자원 의존성. 테스트가 끝나고 실행되는 사이에 공유되는 상태를 정리해줘야 함.

테스트 감지 자동화 도구
- 최근에 변경된 코드의 커버리지를 모니터링 하는 도구 DeFlaker
- 테스트를 임의의 순서로 실행하며 불안정성을 찾아주는 iDFlakies
테스트 도구들이 완벽하지는 않기 때문에 우리가 직접 찾는게 베스트.

### 10.1.5 테스트의 단언문은 탄탄해야한다

테스트는 수행한 코드가 예상대로 동작했다고 단언하는 역할을 함.
단언문을 잘 작성해야 좋은 테스트 코드를 만들 수 있다.

단언문이 없는 경우도 있음..

### 10.1.6 테스트는 행위가 변경될 경우 깨져야 한다

행위가 깨졌는데 테스트가 여전히 성공하면 문제가 있음.

약한 단언문이나, 메서드는 수행되지만 테스트가 제대로 되지 않아 발생할 수 있음
TDD는 사이클은 언제나 깨지는 것을 확인하는 단계가 있다.

### 10.1.7 테스트는 단 하나의 명확한 이유로 실패해야 한다

테스트에 의도와 행위를 표현하는 이름을 지정하자.

### 10.1.8 테스트는 작성하기 쉬워야 한다

인프라 설정하고 정리하는 테스트도 필요
테스트를 작성하기 쉽게 하자. 개발자에게 그렇게 할 수 있는 모든 도구를 제공하자.
### 10.1.9 테스트는 읽기 쉬워야 한다

읽는 시간을 절약하면 생산성이 올라간다.
리팩터링에 시간을 투자하는 것을 두려워 말자.

### 10.1.10 테스트는 쉽게 수정하고 진화할 수 있어야 한다

테스트 코드를 구현할 때 해야 할 일은 코드의 변경이 너무 고통스럽지 않도록 하는 것

예) 열 개의 테스트 메서드에서 동일한 코드 조각이 있으면 이를 추출

## 10.2 테스트 냄새

길이가 긴 메서드, 길이가 긴 클래스, 전지전능 클래스 ...

### 10.2.1 과다한 중복

테스트는 종종 구조가 유사함.

중복은 생산성 저하.
약간의 중복은 해가 되지 않을 수 있으니, 경험을 사용해서 리팩토링 판단해야함.

### 10.2.2 불명확한 단언문

단언문은 테스트가 실패했을 때 개발자가 가장먼저 살펴보는 내용.

실패했을 때 이유를 이해하기 어려울 때 테스트 냄새가 남.

너무 복잡해서
- 주석으로라도 설명해주기

메서드당 하나의 단언문 -> 저자는 반대함
충분히 응집력 있고 단일 기능에 초점을 맞췄다면, 단언문들은 전체 행위가 예상한 바와 같다는 것을 보장함

소프트단언.
테스트가 실패했을 때 즉시 중지하지 않고, 해당 테스트가 끝나는 시점에 결과를 한번에 보고하는 기능.


적당한 단언문을 잘 사용해야함.

### 10.2.3 복잡하거나 외부에 있는 자원에 대한 잘못된 처리

